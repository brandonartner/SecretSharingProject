import numpy as np
from Crypto.Util import number
from Crypto.Random import random
import math
import string

from fractions import Fraction

class Polynomial:
    ''' Class to evaluate simulated polynomials '''

    def __init__(self, coefficients):
        self.coefficients = coefficients
        self.degree = len(self.coefficients) - 1

    def evaluate(self, x):
        value = 0

        for i, c in enumerate(self.coefficients):
            value += c * x ** (self.degree - i)

        return value

    def stringify(self):
        s = ''

        for i, c in enumerate(self.coefficients):
            s = s + '{}*x**{}'.format(c, self.degree - i)

            if i < self.degree:
                s = s + '+'

        return s


def random_distinct(lower_bound, upper_bound, size):
    """Generates lists of distinct random numbers,
    
    Args:
        lower_bound (int): Low bound for searching.
        upper_bound (int): High bound for searching.
        size (int): Length of list of numbers.

    Returns:
         int: List of random numbers within given bounds.

    """

    v = []

    while len(v) < size:
        rand = random.randint(lower_bound, upper_bound)
        
        if rand not in v:
            v.append(rand)
            
    return v

def generate_polynomial(data, k, p):
    """Makes a random polynomial with data as the coeficient term.

    Args:
        data (int): The data as a numeric value to be split.
        k (int): The number of points required to interpolate the polynomial, 
                    which is the polynomial's order plus one.
        p (int): The prime modulus.

    Returns: 
        Polynomial: polynomial as a lambda function.

    """

    # Shamir's algorithms requires each coefficient to be distinct
    coefficients = random_distinct(0, p, k-1)
    # set data as 0th degree term
    coefficients.append(data)

    polynomial = Polynomial(coefficients)
    
    return polynomial

def generate_keys(poly, n, p):
    """Creates the keys for distributing.

    Args:
        poly (Polynomial): Polynomial function to create the keys.
        n (int): 
        p (int): The prime modulus.

    Returns: 
        list of int tuples: list of key pairs generated by Shamir's Scheme.

    """

    # create distinct x values because f(a)=f(b) iff a=b 
    # implies less than n keys will be made
    X = range(1, n+1)

    # get corresponding y values
    Y = [poly.evaluate(x) % p for x in X]

    return list(zip(X, Y))

def nthOrderLag(values, n):
    """Calculates the (n)th-ordered Lagrangian Interpolating Polynomial, evaluated at 0.
    
    Args:
        n (int): The order of the next LIP.

    Returns:
        Fraction: A fraction containing the value of the nth LIP, evaluated at 0.

    """

    j = -1
    i = j - (n + 1)

    x1 = values[0][i]
    x2 = values[0][j]

    y1 = values[n+1][-2]
    y2 = values[n+1][-1]

    num = (0-x2)*y1-(0-x1)*y2
    den = x1-x2
    return Fraction(num, den)


def find_divisible_congruency(fraction, p):
    """Calculates a congruent integer to the numerator that is divisible by the denominator.

    Args:
        fraction (Fraction): fraction, the fraction in question.

    Returns: 
        int: The z such that z = (num + i*prime)/den and z is an integer (without trunction).

    """

    # Fracction class is used here because float division can't handle crypto-secure sized numbers,
    #  but Fraction uses integers, which can handle effectively infinite numbers
    num = Fraction(fraction.numerator % p,1)
    den = Fraction(fraction.denominator % p,1)

    i = 0
    z = (p*i+num)/den

    while z != int(z):
        i += 1
        z = (p*i+num)/den

    return int(z)

def key_to_data(key, n):
    """Calculates a congruent integer to the numerator that is divisible by the denominator.

    Args:
        key (int, int): The key pair to be encoded.
        n (int): The maximum number the first term in the key can be.

    Returns: 
        int: data. The key pair encoded as an integer.

    """

    x, y = key
    
    xbin = bin(x)[2:]
    ybin = bin(y)[2:]

    # This now pads to make the first number the same bit length of the prime
    databin = '1' +xbin.zfill(len(bin(n)[2:])) + ybin
    data = int(databin, 2)

    return data

def data_to_key(data,p):
    """Calculates a congruent integer to the numerator that is divisible by the denominator.

    Args:
        data (int): .
        n (int): The maximum number the first term in the key can be.

    Returns: 
        (int, int): key. The key pair from the given encoded integer.

    """

    databin = bin(data)[2:]
    prime_bit_len = len(bin(p)[2:])

    xbin = databin[1:prime_bit_len+1]
    ybin = databin[prime_bit_len+1:]

    x = int('0b'+xbin, 2)
    y = int('0b'+ybin, 2)

    key = (x, y)

    return key

def next_multiple_of_128(data):
    '''Calculates the smallest number of bits bigger than the length of data and a multiple of 128.
    '''
    bin_data_len = len(bin(data)[2:]) 

    return math.ceil(bin_data_len/128)*128

def convvert_to_PEM(private_key):
    """ Converts a private key integer to PEM format

    Todo:
        Implement this... Maybe... This may be needed for making document sets on lower levels of the hierarchy.
    """
    base64_key = 0

def base_convert(n, base):
    digits = string.printable[:-6]
    
    if n < base:
        return digits[n]

    else:
        return base_convert(n//base, base) + digits[n%base]
        


if __name__ == '__main__':
    from SlowNeville import SlowNeville

    np.random.seed(0)

    n = 8
    k = 5
    print('({}, {})-thresholding scheme'.format(n, k))

    D = 10
    print('Original data:', D)

    polynomial, p = generate_polynomial(D, k)
    print('Arithmetic modulo', p)
    print('Created polynomial:', polynomial.stringify())

    keys = generate_keys(n, polynomial, p)
    for key in keys:
        print('Generated key:', key)

    not_enough_keys = sample(keys, k-1)
    enough_keys = sample(keys, k)

    print('Incorrectly decrypted data:', decrypt(not_enough_keys, p))
    print('Correctly decrypted data:', decrypt(enough_keys, p))
